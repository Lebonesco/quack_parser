/* Lexical Parser */

!whitespace : '\t' | '\n' | '\r' | ' ' ;


_letter : 'A'-'Z' | 'a'-'z' | '_' ;
_digit : '0'-'9' ;
_alpha : _letter | _digit ;

class : 'c' 'l' 'a' 's' 's' ;
def : 'd' 'e' 'f' ;
let: 'l' 'e' 't' ;
extends : 'e' 'x' 't' 'e' 'n' 'd' 's';
if : 'i' 'f' ;
elif : 'e' 'l' 'i' 'f' ;
else : 'e' 'l' 's' 'e' ;
while : 'w' 'h' 'i' 'l' 'e' ;
return : 'r' 'e' 't' 'u' 'r' 'n' ;
typecase : 't' 'y' 'p' 'e' 'c' 'a' 's' 'e' ;
true : 't' 'r' 'u' 'e' ;
false : 'f' 'a' 'l' 's' 'e' ;
or : 'o' 'r' ;
not : 'n' 'o' 't' ;
and : 'a' 'n' 'd' ;

/* predefined identifiers */
_valid_escape : '\\' ( '0' | 'b' | 't' | 'n' | 'r' | 'f' | '"' | '\\') ;
_not_escape : 'a' | 'c' | 'd' | 'e' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l'
					| 'm' | 'o' | 'p' | 'q' | 's' | 'u' | 'v' | 'w' 
					| 'x' | 'y' | 'z' ;
string_escape_error : '"'{(_alpha | ' ')}  '\\' _not_escape {(_alpha | ' ')}  '"' ;
//string_newline_error : '"' {.} '\\' 'n' ;
string_literal : '"' {(_alpha | ' ' | '{' | '}' | '[' | ']' | '~' | ',' | '.' | ';' | ':' 
						| '^' | '!' | '@' | '#' | '$' | '%' | '&' | '*' | '(' | ')' | '-' | '?' | '<' | '>' | '|' | '=' | '/'
						| '+')} '"' ;
int : '1'-'9' {_digit} ;

ident : 'S' 't' 'r' 'i' 'n' 'g' | 'I' 'n' 't' | 'O' 'b' 'j' | 'B' 'o' 'o' 'l' 'e' 'a' 'n'
		| 'N' 'o' 't' 'h' 'i' 'n' 'g' | 'n' 'o' 'n' 'e' | _letter {_alpha} ;

// --- [ Comments (suppressed) ] -----------------------------------------------
!comment      : _lineComment | _blockComment | _tripleQuoteComment ;
_lineComment  : '/' '/' { . } '\n' ;
_blockComment : '/' '*' { . | '*' } '*' '/' ;
_tripleQuoteComment : '"' '"' '"' { . } '"' '"' '"' ;

/* punctuation */
plus : '+' ;
minus : '-' ;
mul : '*' ;
div : '/' ;

eq : '=' '=' ;
neq : '!' '=' ;
atmost : '<' '=' ;
lt : '<' ;
atleast : '>' '=' ;
gt : '>' ;

lbrace : '{' ;
rbrace : '}' ;
assign : '=' ;
lparen : '(' ;
rparen : ')' ;
comma : ',' ;
semicolon : ';' ;
period : '.' ;
colon : ':' ;

unknown : . ; // catch unmatched tokens

/* Syntactic Parser */

<<
import (
//	"github.com/Lebonesco/quack_parser/token"
//	"github.com/Lebonesco/quack_parser/util"
	"github.com/Lebonesco/quack_parser/ast"
)
>>

Program 
	: Class Statements << ast.NewProgram($0, $1) >>
	;

Class
	: Class ClassSignature ClassBody	<< ast.AppendClass($0, $1, $2) >>
	| empty								<< ast.NewClass() >>
	;

Statements
	: Statements Statement 	<< ast.AppendStatement($0, $1) >>
	| empty					<< ast.NewStatementList() >>
	;

ClassSignature 
	: class ident lparen FormalArgs rparen Extend << ast.NewClassSignature($1, $3, $5) >>
	;

Extend
	: extends ident << ast.NewExtends($1) >>
	| empty
	;

FormalArgs 
	: ident colon ident FormalArgsList << ast.AppendFormalArgs($0, $2, $3) >> 
	| empty 
	;

FormalArgsList
	: FormalArgsList comma ident colon ident << ast.AppendFormalArgs($2, $4, $0) >> 
	| empty									 << ast.NewFormalArg() >>
	;

ClassBody 
	: lbrace Statements Method rbrace	<< ast.NewClassBody($1, $2) >>
	;

Method 
	: Method def ident lparen FormalArgs rparen Type StatementBlock << ast.AppendMethod($0, $2, $4, $6, $7) >>
	| empty															<< ast.NewMethod() >>
	;

StatementBlock 
	: lbrace Statements rbrace	<< ast.NewStatementBlock($1) >> 
	;

Statement 
		: if RExpr StatementBlock IfStatement		 << ast.NewIfStatement($1, $2, $3) >>
		| while RExpr StatementBlock				 << ast.NewWhileStatement($1, $2) >>
		| let LExpr assign RExpr semicolon			 << ast.NewLetStatement($1, $3) >>
		| RExpr semicolon							 << ast.NewExpressionStatement($0) >>
		| return semicolon							
		| return RExpr semicolon						<< ast.NewReturnExpression($1) >>
		| Typecase
		;

// define variable type
Type
	: colon ident
	| empty
	;

IfStatement
	: elif RExpr StatementBlock IfStatement         << ast.NewIfStatement($1, $2, $3) >>
	| else StatementBlock 							<< $1, nil >> 
	| empty
	;

LExpr : ident 										<< ast.NewIdentifier($0) >>
	  | RExpr period ident 							<< ast.NewClassVariable($0, $2) >>
	  ;

RExpr 
	  : string_literal								<< ast.NewStringLiteral($0) >>
      | RExpr plus Term 							<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr minus Term 							<< ast.NewInfixExpression($0, $1, $2) >>
      | minus Term
      | RExpr atleast Term							<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr atmost Term							<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr lt Term			    				<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr gt Term								<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr eq Term								<< ast.NewInfixExpression($0, $1, $2) >>
      | RExpr neq Term								<< ast.NewInfixExpression($0, $1, $2) >>
      | Term
      | ident lparen ActualArgs rparen				<< ast.NewFunctionCall($0, $2) >> 
      | ident 										<< ast.NewIdentifier($0) >>
      | RExpr and Bool								<< ast.NewBoolExpr($0, $2, "and") >>
      | RExpr or Bool    							<< ast.NewBoolExpr($0, $2, "or") >>
      | not Bool 									<< !$1.(bool), nil >>
      | Bool  										<< ast.NewBool($0) >>
      | RExpr period ident lparen ActualArgs rparen	
      | error
      ;

Term 
	: Term mul Factor      	<< ast.NewInfixExpression($0, $1, $2) >>
	| Term div Factor		<< ast.NewInfixExpression($0, $1, $2) >>
	| Factor 				
	;

Factor
	: lparen RExpr rparen	<< $1, nil >>
	| int 					<< ast.NewIntLiteral($0) >>
	;

Bool
	: true                  << true, nil >>
	| false					<< false, nil >>
	;

ActualArgs
	: RExpr ArgsList                           << ast.AppendArgs($1, $0) >>
	| empty 			
	;

ArgsList
	: comma RExpr ArgsList                      << ast.AppendArgs($2, $1) >>
	| empty										<< ast.NewArg() >> 
	;

Typecase : typecase RExpr lbrace TypeAlternative rbrace ;

TypeAlternative
	 : ident colon ident StatementBlock TypeAlternative
	 | empty
	 ;